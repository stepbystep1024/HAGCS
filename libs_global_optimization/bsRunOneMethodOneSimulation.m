function [xOut, funVal, exitFlag, OUTPUT] = bsRunOneMethodOneSimulation(fobj, methodName, parameters, ...
    lower, upper, ...
    optimalFunctionTolerance, maxIter, minFVal, maxFevs, ...
    isSaveMiddleRes, isSaveDetailUpdates)
%% optimize the objective function for one method
% this script will be used in 
% testCompareMethodsFinal.m
% testLargeScale.m
% and showAnimation.m

    nDim = length(lower);
    
    % obtain the number of initial population size
    if isa(parameters{1},'function_handle')
        nInitNest = parameters{1}(nDim);
    else
        nInitNest = parameters{1};
    end
    
    a = 0.495 + 0.005 * rand(nDim, 1);
    center = a.*lower + (1-a).*upper;
    
    function [f, g] = bsObjFcn(x, y)
        [n, m] = size(x);
        o = repmat(center, 1, m);
        if nargin == 1
            [f, g] = fobj(x-o);
        else
            [f, g] = fobj(x-o, y);
        end
    end
%     bsObjFcn = fobj;
    
    switch methodName
        % test different methods

        case 'CS'
            % Cuckoo search algorithm
            pa = parameters{2};
            alpha = parameters{3};
            initialPopFcn = parameters{4};
            objFunc = @(x)(bsObjFcn(x, 0));    % CS algorithm doesn't need the gradient information
%             CSObjFunc = objFunc;
            
            [xOut, funVal, exitFlag, OUTPUT] = bsCSByYangAndDeb2009(objFunc, lower, upper, ...
                'nNest', nInitNest, ...
                'pa', pa, ...
                'alpha', alpha, ...
                'initialPopulationFcn', initialPopFcn,...
                'optimalFunctionTolerance', optimalFunctionTolerance, ...
                'maxIter', maxIter, ...
                'optimalF', minFVal, ...
                'isSaveMiddleRes', isSaveMiddleRes, ...
                'isSaveDetailUpdates', isSaveDetailUpdates, ...
                'maxFunctionEvaluations', maxFevs);
        case 'GBCS'
            % gradient-based cuckoo search algorithm
            pa = parameters{2};
            alpha = parameters{3};
            initialPopFcn = parameters{4};
            objFunc = @(x)(bsObjFcn(x, 1));
            
            [xOut, funVal, exitFlag, OUTPUT] = bsGBCSByFateen2014(objFunc, lower, upper, ...
                'nNest', nInitNest, ...
                'pa', pa, ...
                'alpha', alpha, ...
                'initialPopulationFcn', initialPopFcn,...
                'optimalFunctionTolerance', optimalFunctionTolerance, ...
                'maxIter', maxIter, ...
                'optimalF', minFVal, ...
                'isSaveMiddleRes', isSaveMiddleRes, ...
                'isSaveDetailUpdates', isSaveDetailUpdates, ...
                'maxFunctionEvaluations', maxFevs);

        case 'AGBCS'
            % advanced gradient-based cuckoo search
            pa = parameters{2};
            alpha = parameters{3};
            initialPopFcn = parameters{4};
            interval = parameters{5};
            innerMaxIter = parameters{6};
            objFunc = @(x)(bsObjFcn(x, 1));
            
            [xOut, funVal, exitFlag, OUTPUT] = bsAGBCSByShe2022(objFunc, lower, upper, ...
                'nNest', nInitNest, ...
                'pa', pa, ...
                'alpha', alpha, ...
                'initialPopulationFcn', initialPopFcn,...
                'interval', interval, ...
                'innerMaxIter', innerMaxIter,...
                'optimalFunctionTolerance', optimalFunctionTolerance, ...
                'maxIter', maxIter, ...
                'optimalF', minFVal, ...
                'isSaveMiddleRes', isSaveMiddleRes, ...
                'isSaveDetailUpdates', isSaveDetailUpdates, ...
                'maxFunctionEvaluations', maxFevs);

        case 'AHSACS'
            % advanced hybrid self-adpatation cuckoo search 
            maxNest = nInitNest;
            minNest = parameters{2};
            
            % obtain the size of history 
            if isa(parameters{1},'function_handle')
                nHistory = parameters{3}(nDim);
            else
                nHistory = parameters{3};
            end
    %                         
            initialPopFcn = parameters{4};
            objFunc = @(x)(bsObjFcn(x, 0));
            
            [xOut, funVal, exitFlag, OUTPUT] = bsAHSACSByShe2022(objFunc, lower, upper, ...
                'maxNests', maxNest, ...
                'minNests', minNest,...
                'nHistory', nHistory, ...
                'initialPopulationFcn', initialPopFcn,...
                'optimalFunctionTolerance', optimalFunctionTolerance, ...
                'maxIter', maxIter, ...
                'optimalF', minFVal, ...
                'isSaveMiddleRes', isSaveMiddleRes, ...
                'isSaveDetailUpdates', isSaveDetailUpdates, ...
                'maxFunctionEvaluations', maxFevs);

        case 'HAGCS'
            % Our proposed method: hybrid self-adaptation gradient-based cuckoo search algorithm
            minNest = parameters{2};
%             nHistory = parameters{3};
            initialPopFcn = parameters{4};
            interval = parameters{5};
            innerMaxIter = parameters{6};

            % obtain the size of history 
            if isa(parameters{1},'function_handle')
                nHistory = parameters{3}(nDim);
            else
                nHistory = parameters{3};
            end
            objFunc = @(x)(bsObjFcn(x, 1));
            
            [xOut, funVal, exitFlag, OUTPUT] = bsHAGCSByShe2022(objFunc, lower, upper, ...
                'maxNests', nInitNest, ...
                'minNests', minNest,...
                'nHistory', nHistory, ...
                'display', 'off', ...
                'initialPopulationFcn', initialPopFcn,...
                'interval', interval, ...
                'innerMaxIter', innerMaxIter,...
                'optimalFunctionTolerance', optimalFunctionTolerance, ...
                'maxIter', maxIter, ...
                'optimalF', minFVal, ...
                'isSaveMiddleRes', isSaveMiddleRes, ...
                'isSaveDetailUpdates', isSaveDetailUpdates, ...
                'maxFunctionEvaluations', maxFevs);
        
        case 'MSACS'
            % Adaptive cuckoo algorithm with multiple search strategies 
            pa = parameters{2};
            alpha = parameters{3};
            initialPopFcn = parameters{4};
            objFunc = @(x)(bsObjFcn(x, 0));    % CS algorithm doesn't need the gradient information
%             CSObjFunc = objFunc;
            
            [xOut, funVal, exitFlag, OUTPUT] = bsMSACSByGao2021(objFunc, lower, upper, ...
                'nNest', nInitNest, ...
                'pa', pa, ...
                'alpha', alpha, ...
                'initialPopulationFcn', initialPopFcn,...
                'optimalFunctionTolerance', optimalFunctionTolerance, ...
                'maxIter', maxIter, ...
                'optimalF', minFVal, ...
                'isSaveMiddleRes', isSaveMiddleRes, ...
                'isSaveDetailUpdates', isSaveDetailUpdates, ...
                'maxFunctionEvaluations', maxFevs);
        
        case 'CSAPC'
            % Adaptive cuckoo algorithm with multiple search strategies 
            pa = parameters{2};
            alpha = parameters{3};
            initialPopFcn = parameters{4};
            objFunc = @(x)(bsObjFcn(x, 0));    % CS algorithm doesn't need the gradient information
%             CSObjFunc = objFunc;
            
            [xOut, funVal, exitFlag, OUTPUT] = bsCSAPCByWei2020(objFunc, lower, upper, ...
                'nNest', nInitNest, ...
                'pa', pa, ...
                'alpha', alpha, ...
                'initialPopulationFcn', initialPopFcn,...
                'optimalFunctionTolerance', optimalFunctionTolerance, ...
                'maxIter', maxIter, ...
                'optimalF', minFVal, ...
                'isSaveMiddleRes', isSaveMiddleRes, ...
                'isSaveDetailUpdates', isSaveDetailUpdates, ...
                'maxFunctionEvaluations', maxFevs);

        case 'PSO'
            % particle swarm optimization 
            PSOObjFunc = @(x)(bsObjFcn(x', 0));

            psoOpts = optimoptions('particleswarm', ...
                'MaxIterations', round(maxFevs/nInitNest)+1, ...
                'ObjectiveLimit', minFVal+optimalFunctionTolerance,...
                'FunctionTolerance', 1e-100,...
                'OutputFcn', @(x, y)bsPSOOutFcn(x, y, minFVal, optimalFunctionTolerance),...
                'SwarmSize', nInitNest);

            [xOut, funVal, exitFlag, OUTPUT] = particleswarm(PSOObjFunc, nDim, lower, upper, psoOpts);

            OUTPUT.funcCount = OUTPUT.funccount;
            
        case 'GA'
            % genetic algorithm
            GAObjFunc = @(x)(bsObjFcn(x', 0));

            gaOpts = optimoptions('ga', 'FitnessLimit', minFVal+optimalFunctionTolerance, ...
                'MaxGenerations', round(maxFevs/nInitNest)+1, ...
                'FunctionTolerance', 1e-100,...
                'OutputFcn', @(x, y, z)bsGAOutFcn(x, y, z, minFVal, optimalFunctionTolerance), ...
                'PopulationSize', nInitNest);

            [xOut, funVal, exitFlag, OUTPUT] = ga(GAObjFunc, nDim, [], [], [], [], lower, upper, [], [], gaOpts);

            OUTPUT.iterations = OUTPUT.generations;
            OUTPUT.funcCount = OUTPUT.funccount;

    end
end